<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pen-Plotter City Blocks</title>
  <style>
    :root { --bg:#fff; --fg:#111; --ui:#f2f2f2; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .app{display:grid;grid-template-columns:320px 1fr;height:100vh}
    .panel{padding:14px;border-right:1px solid #ddd;background:var(--ui);overflow:auto}
    .panel h1{font-size:18px;margin:0 0 8px}
    .row{margin:10px 0}
    label{display:flex;align-items:center;justify-content:space-between;gap:10px;font-weight:600}
    input[type="range"]{width:100%}
    input[type="text"]{width:140px;padding:6px}
    button{cursor:pointer;padding:8px 10px;border:1px solid #000;background:#fff;color:#000;border-radius:8px}
    .small{font-size:12px;opacity:.75}
    .canvas-wrap{position:relative;width:100%;height:100%}
    canvas{display:block;width:100%;height:100%;background:var(--bg)}
    .hud{position:absolute;left:12px;bottom:12px;background:rgba(255,255,255,.85);color:#000;padding:6px 8px;border:1px solid #000;border-radius:8px;font-size:12px}
    .group{border:1px dashed #bbb;padding:10px;border-radius:10px;background:#fff}
  </style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h1>Skyrise City — Pen-Plotter Lines</h1>

    <div class="row group">
      <div class="row"><label>Seed <input id="seed" type="text" value="city-42" /></label></div>
      <div class="row" style="display:flex;gap:8px;">
        <button id="btn-apply-seed">Apply seed</button>
        <button id="btn-random-seed">Randomize</button>
      </div>
      <div class="small">Seed controls the building heights. Same seed ⇒ same city.</div>
    </div>

    <div class="row group" style="margin-top:10px;">
      <div class="row"><label>Azimuth (°) <input id="azimuth" type="range" min="0" max="360" step="1" value="45" /></label></div>
      <div class="row"><label>Elevation (°) <input id="elevation" type="range" min="5" max="85" step="1" value="35" /></label></div>
      <div class="row"><label>Camera distance <input id="camDist" type="range" min="10" max="200" step="1" value="90" /></label></div>
      <div class="row"><label>FOV (°) <input id="fov" type="range" min="20" max="120" step="1" value="55" /></label></div>
      <div class="small">Tip: drag on canvas to orbit. Scroll to zoom.</div>
    </div>

    <div class="row group" style="margin-top:10px;">
      <div class="row"><label>Grid size <input id="gridN" type="range" min="6" max="50" step="1" value="18" /></label></div>
      <div class="row"><label>Block spacing <input id="spacing" type="range" min="0" max="30" step="1" value="12" /></label></div>
      <div class="row"><label>Max height <input id="maxH" type="range" min="10" max="200" step="1" value="120" /></label></div>
      <div class="row"><label>Stroke width (px) <input id="strokeW" type="range" min="0.5" max="3" step="0.1" value="1.2" /></label></div>
    </div>

    <div class="row" style="margin-top:10px;display:flex;gap:8px;">
      <button id="btn-reset-view">Reset view</button>
      <button id="btn-save-svg">Save SVG</button>
    </div>

    <div class="small">Pen-plotter friendly: black lines, uniform stroke; preview uses white fills to hide hidden edges.</div>
  </div>

  <div class="canvas-wrap">
    <canvas id="c"></canvas>
    <div class="hud" id="hud">—</div>
  </div>
</div>

<script>
  // --- Seeded PRNG ---
  function xfnv1a(str){for(var i=0,h=2166136261>>>0;i<str.length;i++) h=Math.imul(h^str.charCodeAt(i),16777619);return()=>{h+=h<<13;h^=h>>>7;h+=h<<3;h^=h>>>17;return(h+=h<<5)>>>0}}
  function mulberry32(a){return()=>{var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}

  // --- Vec/Mat helpers ---
  const V={
    add:(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
    sub:(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
    dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
    cross:(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]],
    norm:(a)=>{const d=Math.hypot(a[0],a[1],a[2]);return d?[a[0]/d,a[1]/d,a[2]/d]:[0,0,0]}
  };
  function lookAt(eye,target,up){
    const z=V.norm(V.sub(eye,target)), x=V.norm(V.cross(up,z)), y=V.cross(z,x);
    const tx=-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]);
    const ty=-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]);
    const tz=-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]);
    return [x[0],x[1],x[2],tx, y[0],y[1],y[2],ty, z[0],z[1],z[2],tz, 0,0,0,1];
  }
  function perspective(fovY,aspect,near,far){
    const f=1/Math.tan((fovY*Math.PI/180)/2), nf=1/(near-far);
    return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,2*far*near*nf, 0,0,-1,0];
  }
  function mulM4(a,b){
    const o=new Array(16).fill(0);
    for(let r=0;r<4;r++)for(let c=0;c<4;c++)
      o[r*4+c]=a[r*4+0]*b[0*4+c]+a[r*4+1]*b[1*4+c]+a[r*4+2]*b[2*4+c]+a[r*4+3]*b[3*4+c];
    return o;
  }
  function transformPt(m,v){
    const x=v[0],y=v[1],z=v[2];
    const X=m[0]*x+m[1]*y+m[2]*z+m[3];
    const Y=m[4]*x+m[5]*y+m[6]*z+m[7];
    const Z=m[8]*x+m[9]*y+m[10]*z+m[11];
    const W=m[12]*x+m[13]*y+m[14]*z+m[15];
    return [X,Y,Z,W];
  }
  function transformPt4(m, v3){
    const x=v3[0],y=v3[1],z=v3[2];
    const X=m[0]*x+m[1]*y+m[2]*z+m[3];
    const Y=m[4]*x+m[5]*y+m[6]*z+m[7];
    const Z=m[8]*x+m[9]*y+m[10]*z+m[11];
    const W=m[12]*x+m[13]*y+m[14]*z+m[15];
    return [X,Y,Z,W];
  }
  function toScreen(pt,w,h){
    const invW=1/pt[3]; const nx=pt[0]*invW, ny=pt[1]*invW, nz=pt[2]*invW;
    return [(nx*.5+.5)*w, (1-(ny*.5+.5))*h, nz];
  }

  // --- Near-plane clipping in VIEW space (z_v <= -near) ---
  function clipAgainstNearView(viewVerts, near){
    const out=[];
    const n=viewVerts.length;
    const inside = (p)=> p[2] <= -near; // camera looks down -Z
    for(let i=0;i<n;i++){
      const a=viewVerts[i], b=viewVerts[(i+1)%n];
      const ina=inside(a), inb=inside(b);
      if(ina && inb){
        out.push(b);
      } else if(ina && !inb){
        const t = ( -near - a[2] ) / ( (b[2]-a[2]) || 1e-12 );
        out.push([ a[0]+t*(b[0]-a[0]), a[1]+t*(b[1]-a[1]), -near ]);
      } else if(!ina && inb){
        const t = ( -near - a[2] ) / ( (b[2]-a[2]) || 1e-12 );
        out.push([ a[0]+t*(b[0]-a[0]), a[1]+t*(b[1]-a[1]), -near ]);
        out.push(b);
      }
    }
    return out;
  }

  // --- Canvas / UI ---
  const canvas=document.getElementById('c'), ctx=canvas.getContext('2d'), hud=document.getElementById('hud');
  let DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
  function resize(){const r=canvas.getBoundingClientRect();canvas.width=Math.floor(r.width*DPR);canvas.height=Math.floor(r.height*DPR);ctx.setTransform(DPR,0,0,DPR,0,0);draw()}
  window.addEventListener('resize',resize);

  const azimuth=document.getElementById('azimuth');
  const elevation=document.getElementById('elevation');
  const camDist=document.getElementById('camDist');
  const fov=document.getElementById('fov');
  const gridN=document.getElementById('gridN');
  const spacing=document.getElementById('spacing');
  const maxH=document.getElementById('maxH');
  const strokeW=document.getElementById('strokeW');
  const seedEl=document.getElementById('seed');
  const btnApplySeed=document.getElementById('btn-apply-seed');
  const btnRandomSeed=document.getElementById('btn-random-seed');
  const btnResetView=document.getElementById('btn-reset-view');
  const btnSaveSvg=document.getElementById('btn-save-svg');

  [azimuth,elevation,camDist,fov,gridN,spacing,maxH,strokeW].forEach(el=>el.addEventListener('input',draw));
  btnResetView.addEventListener('click',()=>{azimuth.value=45;elevation.value=35;camDist.value=90;fov.value=55;draw()});
  btnSaveSvg.addEventListener('click', exportSVG);
  function randomizeSeed(){seedEl.value='city-'+Math.random().toString(16).slice(2,8);regenerateHeights()}
  btnRandomSeed.addEventListener('click',randomizeSeed);
  btnApplySeed.addEventListener('click',regenerateHeights);
  gridN.addEventListener('change',regenerateHeights);

  // Orbit (invert Y)
  let dragging=false,lastX=0,lastY=0;
  canvas.addEventListener('mousedown',e=>{dragging=true;lastX=e.clientX;lastY=e.clientY});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
    azimuth.value=((parseFloat(azimuth.value)+dx*0.5)%360+360)%360;
    // inverted Y: dragging up lowers elevation
    elevation.value=Math.min(85,Math.max(5,parseFloat(elevation.value)+dy*0.3));
    draw();
  });

  // Trackpad scroll to zoom
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const min = parseFloat(camDist.min), max = parseFloat(camDist.max);
    const cur = parseFloat(camDist.value);
    const k = e.ctrlKey ? 0.02 : 0.1; // gentle when pinch zoom
    const next = Math.min(max, Math.max(min, cur + e.deltaY * k)); // +deltaY => zoom out
    camDist.value = String(next);
    draw();
  }, { passive:false });

  // --- City data ---
  let city={normHeights:[],n:parseInt(gridN.value)};
  function regenerateHeights(){
    const n=parseInt(gridN.value);
    city.n=n;
    const seedHash=xfnv1a(seedEl.value)();
    const rng=mulberry32(seedHash);
    const norm=new Array(n*n);
    for(let j=0;j<n;j++){
      for(let i=0;i<n;i++){
        const idx=j*n+i;
        const base=rng();
        const power=Math.pow(base,2.2);
        norm[idx]=power;
      }
    }
    city.normHeights=norm;
    draw();
  }

  // --- Geometry ---
  function buildFaces(n,spacingPx,H){
    const cell=12, step=cell+spacingPx, half=(n-1)*step*0.5;
    const faces=[];
    for(let j=0;j<n;j++)for(let i=0;i<n;i++){
      const h=city.normHeights[j*n+i]*H, cx=i*step-half, cy=j*step-half, s=cell;
      const x1=cx-s*0.5,x2=cx+s*0.5,y1=cy-s*0.5,y2=cy+s*0.5,z0=0,z1=h;
      const p000=[x1,y1,z0], p100=[x2,y1,z0], p110=[x2,y2,z0], p010=[x1,y2,z0];
      const p001=[x1,y1,z1], p101=[x2,y1,z1], p111=[x2,y2,z1], p011=[x1,y2,z1];

      // underside removed
      const quads=[
        [p001,p101,p111,p011], // top
        [p000,p100,p101,p001], // side 1
        [p100,p110,p111,p101], // side 2
        [p110,p010,p011,p111], // side 3
        [p010,p000,p001,p011], // side 4
      ];

      for(const q of quads){
        const e1=[q[1][0]-q[0][0],q[1][1]-q[0][1],q[1][2]-q[0][2]];
        const e2=[q[2][0]-q[0][0],q[2][1]-q[0][1],q[2][2]-q[0][2]];
        const normal=V.norm([ e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0] ]);
        const center=[(q[0][0]+q[1][0]+q[2][0]+q[3][0])/4,(q[0][1]+q[1][1]+q[2][1]+q[3][1])/4,(q[0][2]+q[1][2]+q[2][2]+q[3][2])/4];
        faces.push({v:q,normal,center});
      }
    }
    return faces;
  }

  // ------- BSP TREE (view space) -------
  const EPS = 1e-6;

  function sideOf(plane, p, eps=EPS){
    const s = plane[0]*p[0] + plane[1]*p[1] + plane[2]*p[2] + plane[3];
    return s > eps ?  1 : (s < -eps ? -1 : 0);
  }
  function triangleArea(a,b,c){
    const ux=b[0]-a[0], uy=b[1]-a[1], uz=b[2]-a[2];
    const vx=c[0]-a[0], vy=c[1]-a[1], vz=c[2]-a[2];
    const cx=uy*vz-uz*vy, cy=uz*vx-ux*vz, cz=ux*vy-uy*vx;
    return Math.hypot(cx,cy,cz)*0.5;
  }
  function planeOf(poly){
    for(let i=1;i<poly.length-1;i++){
      const a=poly[0], b=poly[i], c=poly[i+1];
      const ux=b[0]-a[0], uy=b[1]-a[1], uz=b[2]-a[2];
      const vx=c[0]-a[0], vy=c[1]-a[1], vz=c[2]-a[2];
      let nx=uy*vz-uz*vy, ny=uz*vx-ux*vz, nz=ux*vy-uy*vx;
      const len=Math.hypot(nx,ny,nz);
      if (len>EPS){
        nx/=len; ny/=len; nz/=len;
        const d = -(nx*a[0]+ny*a[1]+nz*a[2]);
        return [nx,ny,nz,d];
      }
    }
    return [0,0,1,0];
  }
  function splitPolyByPlane(plane, poly){
    // Returns { front:[poly...], back:[poly...] } (no coplanars here)
    const front=[], back=[];
    for(let i=0;i<poly.length;i++){
      const a=poly[i], b=poly[(i+1)%poly.length];
      const da = plane[0]*a[0]+plane[1]*a[1]+plane[2]*a[2]+plane[3];
      const db = plane[0]*b[0]+plane[1]*b[1]+plane[2]*b[2]+plane[3];
      const sa = da>EPS?1:da<-EPS?-1:0;
      const sb = db>EPS?1:db<-EPS?-1:0;

      if (sa >= 0) front.push(a); else if (sa < 0) back.push(a); else { front.push(a); back.push(a); }

      if (sa*sb < 0){
        const t = da / (da - db);
        const m = [ a[0] + t*(b[0]-a[0]), a[1] + t*(b[1]-a[1]), a[2] + t*(b[2]-a[2]) ];
        front.push(m); back.push(m);
      }
    }
    const outF = front.length>=3 ? [front] : [];
    const outB = back.length>=3 ? [back] : [];
    return { front: outF, back: outB };
  }
  function chooseSplitter(polys){
    let bestIdx=0, bestA=-1;
    for (let i=0;i<polys.length;i++){
      const p=polys[i]; if (p.length<3) continue;
      let A=0; for(let k=1;k<p.length-1;k++) A += triangleArea(p[0],p[k],p[k+1]);
      if (A>bestA){ bestA=A; bestIdx=i; }
    }
    return bestIdx;
  }
  function buildBSP(polys){
    if (!polys.length) return null;
    const i = chooseSplitter(polys);
    const splitter = polys[i];
    const plane = planeOf(splitter);

    const cop=[], front=[], back=[];
    for (let k=0;k<polys.length;k++){
      if (k===i){ cop.push(splitter); continue; }
      const p = polys[k];
      let pos=0, neg=0;
      for (const v of p){ const s=sideOf(plane, v); if (s>0) pos=1; else if (s<0) neg=1; }
      if (pos && neg){
        const sp = splitPolyByPlane(plane, p);
        front.push(...sp.front); back.push(...sp.back);
      } else if (pos){ front.push(p); }
      else if (neg){ back.push(p); }
      else { cop.push(p); }
    }
    return { plane, cop, front:buildBSP(front), back:buildBSP(back) };
  }
  function traverseBSP(node, eye, out){
    if (!node) return;
    const side = sideOf(node.plane, eye);
    if (side > 0){
      traverseBSP(node.back, eye, out);
      out.push(...node.cop);
      traverseBSP(node.front, eye, out);
    } else {
      traverseBSP(node.front, eye, out);
      out.push(...node.cop);
      traverseBSP(node.back, eye, out);
    }
  }
  function projectPolyToScreen(P, poly, w, h){
    const clip = poly.map(p=>transformPt4(P, p));
    return clip.map(pt=>toScreen(pt, w, h));
  }

  // Compute screen-space polygons (ordered) shared by canvas and SVG
  function computeDrawList(w,h){
    const n=parseInt(gridN.value), space=parseFloat(spacing.value);
    const r=parseFloat(camDist.value), az=parseFloat(azimuth.value)*Math.PI/180, el=parseFloat(elevation.value)*Math.PI/180;
    const eye=[r*Math.cos(el)*Math.cos(az), r*Math.cos(el)*Math.sin(az), r*Math.sin(el)];
    const Vw=lookAt(eye,[0,0,0],[0,0,1]);
    const near=0.1;
    const P=perspective(parseFloat(fov.value), w/h, near, 2000);

    const faces=buildFaces(n,space,parseFloat(maxH.value));

    // Prepare view-space convex polys (near-clipped) + back-face cull
    const viewPolys=[];
    for(const f of faces){
      const viewDir = V.norm([eye[0]-f.center[0],eye[1]-f.center[1],eye[2]-f.center[2]]);
      const facing = (f.normal[0]*viewDir[0]+f.normal[1]*viewDir[1]+f.normal[2]*viewDir[2])>0;
      if(!facing) continue;

      const viewVertsOrig = f.v.map(p=>transformPt(Vw,p)).map(q=>[q[0],q[1],q[2]]);
      const viewVerts = clipAgainstNearView(viewVertsOrig, near);
      if(viewVerts.length >= 3) viewPolys.push(viewVerts);
    }

    // Build + traverse BSP in view space
    const bsp = buildBSP(viewPolys);
    const orderedView = []; traverseBSP(bsp, [0,0,0], orderedView);

    // Project to screen
    const sPolys = orderedView.map(poly => projectPolyToScreen(P, poly, w, h));
    return sPolys;
  }

  function draw(){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.lineWidth=parseFloat(strokeW.value);
    ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle='#000';

    const sPolys = computeDrawList(w,h);

    for(const spts of sPolys){
      ctx.beginPath();
      ctx.moveTo(spts[0][0],spts[0][1]);
      for(let i=1;i<spts.length;i++) ctx.lineTo(spts[i][0],spts[i][1]);
      ctx.closePath();
      ctx.fillStyle='#fff';
      ctx.fill();
      ctx.stroke();
    }

    ctx.restore();
    const n=parseInt(gridN.value);
    hud.textContent=`az ${parseInt(azimuth.value)}°  el ${parseInt(elevation.value)}°  dist ${parseInt(camDist.value)}  fov ${parseInt(fov.value)}°  grid ${n}×${n}  order BSP  maxH ${parseInt(maxH.value)}`;
  }

  // SVG export using the same screen-space polygons
  function exportSVG(){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    const sPolys = computeDrawList(w,h);
    const sw=parseFloat(strokeW.value);

    const xmlns='http://www.w3.org/2000/svg';
    const svg=document.createElementNS(xmlns,'svg');
    svg.setAttribute('xmlns',xmlns);
    svg.setAttribute('width',String(w));
    svg.setAttribute('height',String(h));
    svg.setAttribute('viewBox',`0 0 ${w} ${h}`);

    // Background to emulate the canvas white occlusion
    const bg=document.createElementNS(xmlns,'rect');
    bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width',String(w)); bg.setAttribute('height',String(h));
    bg.setAttribute('fill','#ffffff');
    svg.appendChild(bg);

    const toPathD=(poly)=>{
      let d=`M ${poly[0][0]} ${poly[0][1]}`;
      for(let i=1;i<poly.length;i++) d += ` L ${poly[i][0]} ${poly[i][1]}`;
      return d+' Z';
    };

    for(const poly of sPolys){
      const fill=document.createElementNS(xmlns,'path');
      fill.setAttribute('d',toPathD(poly));
      fill.setAttribute('fill','#ffffff');
      svg.appendChild(fill);

      const stroke=document.createElementNS(xmlns,'path');
      stroke.setAttribute('d',toPathD(poly));
      stroke.setAttribute('fill','none');
      stroke.setAttribute('stroke','#000000');
      stroke.setAttribute('stroke-width',String(sw));
      stroke.setAttribute('stroke-linejoin','round');
      stroke.setAttribute('stroke-linecap','round');
      svg.appendChild(stroke);
    }

    const blob=new Blob([new XMLSerializer().serializeToString(svg)],{type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='city.svg'; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),0);
  }

  // Init
  function init(){regenerateHeights(); resize();}
  window.addEventListener('load',init);
</script>
</body>
</html>
