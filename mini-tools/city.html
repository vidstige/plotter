<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pen-Plotter City Blocks — Scene BSP</title>
  <style>
    :root { --bg:#fff; --fg:#111; --ui:#f2f2f2; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .app{display:grid;grid-template-columns:320px 1fr;height:100vh}
    .panel{padding:14px;border-right:1px solid #ddd;background:var(--ui);overflow:auto}
    .panel h1{font-size:18px;margin:0 0 8px}
    .row{margin:10px 0}
    label{display:flex;align-items:center;justify-content:space-between;gap:10px;font-weight:600}
    input[type="range"]{width:100%}
    input[type="text"]{width:140px;padding:6px}
    button{cursor:pointer;padding:8px 10px;border:1px solid #000;background:#fff;color:#000;border-radius:8px}
    .small{font-size:12px;opacity:.75}
    .canvas-wrap{position:relative;width:100%;height:100%}
    canvas{display:block;width:100%;height:100%;background:var(--bg)}
    .hud{position:absolute;left:12px;bottom:12px;background:rgba(255,255,255,.85);color:#000;padding:6px 8px;border:1px solid #000;border-radius:8px;font-size:12px}
    .group{border:1px dashed #bbb;padding:10px;border-radius:10px;background:#fff}
  </style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h1>Skyrise City — Pen-Plotter Lines</h1>

    <div class="row group">
      <div class="row"><label>Seed <input id="seed" type="text" value="city-42" /></label></div>
      <div class="row" style="display:flex;gap:8px;">
        <button id="btn-apply-seed">Apply seed</button>
        <button id="btn-random-seed">Randomize</button>
      </div>
      <div class="small">Seed controls the building heights. Same seed ⇒ same city.</div>
    </div>

    <div class="row group" style="margin-top:10px;">
      <div class="row"><label>Azimuth (°) <input id="azimuth" type="range" min="0" max="360" step="1" value="45" /></label></div>
      <div class="row"><label>Elevation (°) <input id="elevation" type="range" min="5" max="85" step="1" value="35" /></label></div>
      <div class="row"><label>Camera distance <input id="camDist" type="range" min="10" max="200" step="1" value="90" /></label></div>
      <div class="row"><label>FOV (°) <input id="fov" type="range" min="20" max="120" step="1" value="55" /></label></div>
      <div class="small">Tip: drag on canvas to orbit. Scroll to zoom.</div>
    </div>

    <div class="row group" style="margin-top:10px;">
      <div class="row"><label>Grid size <input id="gridN" type="range" min="6" max="50" step="1" value="18" /></label></div>
      <div class="row"><label>Block spacing <input id="spacing" type="range" min="0" max="30" step="1" value="12" /></label></div>
      <div class="row"><label>Max height <input id="maxH" type="range" min="10" max="200" step="1" value="120" /></label></div>
      <div class="row"><label>Height step <input id="heightStep" type="range" min="1" max="50" step="1" value="5" /></label></div>
      <div class="row"><label>Stroke width (px) <input id="strokeW" type="range" min="0.5" max="3" step="0.1" value="1.2" /></label></div>
    </div>

    <div class="row" style="margin-top:10px;display:flex;gap:8px;">
      <button id="btn-reset-view">Reset view</button>
      <button id="btn-save-svg">Save SVG</button>
    </div>

    <div class="small">Pen-plotter friendly: black lines, uniform stroke; preview uses white fills to hide hidden edges.</div>
  </div>

  <div class="canvas-wrap">
    <canvas id="c"></canvas>
    <div class="hud" id="hud">—</div>
  </div>
</div>

<script>
  // --- Seeded PRNG ---
  function xfnv1a(str){for(var i=0,h=2166136261>>>0;i<str.length;i++) h=Math.imul(h^str.charCodeAt(i),16777619);return()=>{h+=h<<13;h^=h>>>7;h+=h<<3;h^=h>>>17;return(h+=h<<5)>>>0}}
  function mulberry32(a){return()=>{var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}

  // --- Vec/Mat helpers ---
  const V={
    add:(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
    sub:(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
    dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
    cross:(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]],
    norm:(a)=>{const d=Math.hypot(a[0],a[1],a[2]);return d?[a[0]/d,a[1]/d,a[2]/d]:[0,0,0]}
  };
  function lookAt(eye,target,up){
    const z=V.norm(V.sub(eye,target)), x=V.norm(V.cross(up,z)), y=V.cross(z,x);
    const tx=-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]);
    const ty=-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]);
    const tz=-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]);
    return [x[0],x[1],x[2],tx, y[0],y[1],y[2],ty, z[0],z[1],z[2],tz, 0,0,0,1];
  }
  function perspective(fovY,aspect,near,far){
    const f=1/Math.tan((fovY*Math.PI/180)/2), nf=1/(near-far);
    return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,2*far*near*nf, 0,0,-1,0];
  }
  function transformPt4(m, v3){
    const x=v3[0],y=v3[1],z=v3[2];
    const X=m[0]*x+m[1]*y+m[2]*z+m[3];
    const Y=m[4]*x+m[5]*y+m[6]*z+m[7];
    const Z=m[8]*x+m[9]*y+m[10]*z+m[11];
    const W=m[12]*x+m[13]*y+m[14]*z+m[15];
    return [X,Y,Z,W];
  }
  function transformToView(M,v3){
    const r=transformPt4(M,v3); return [r[0],r[1],r[2]];
  }
  function toScreen(pt,w,h){
    const invW=1/pt[3]; const nx=pt[0]*invW, ny=pt[1]*invW;
    return [(nx*.5+.5)*w, (1-(ny*.5+.5))*h];
  }

  // --- Near-plane clipping (view space, polygons & lines) ---
  function clipPolyAgainstNear(viewVerts, near){
    const out=[];
    const n=viewVerts.length;
    const inside = (p)=> p[2] <= -near;
    for(let i=0;i<n;i++){
      const a=viewVerts[i], b=viewVerts[(i+1)%n];
      const ina=inside(a), inb=inside(b);
      if(ina && inb){
        out.push(b);
      } else if(ina && !inb){
        const t = ( -near - a[2] ) / ( (b[2]-a[2]) || 1e-12 );
        out.push([ a[0]+t*(b[0]-a[0]), a[1]+t*(b[1]-a[1]), -near ]);
      } else if(!ina && inb){
        const t = ( -near - a[2] ) / ( (b[2]-a[2]) || 1e-12 );
        out.push([ a[0]+t*(b[0]-a[0]), a[1]+t*(b[1]-a[1]), -near ]);
        out.push(b);
      }
    }
    return out;
  }
  function clipLineNear(a,b,near){
    const ina = a[2] <= -near, inb = b[2] <= -near;
    if(ina && inb) return [a,b];
    if(!ina && !inb) return null;
    const da = -near - a[2], db = -near - b[2];
    const t = da / (da - db);
    const m = [ a[0] + t*(b[0]-a[0]), a[1] + t*(b[1]-a[1]), -near ];
    return ina ? [a,m] : [m,b];
  }

  // --- Canvas / UI ---
  const canvas=document.getElementById('c'), ctx=canvas.getContext('2d'), hud=document.getElementById('hud');
  let DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
  function resize(){const r=canvas.getBoundingClientRect();canvas.width=Math.floor(r.width*DPR);canvas.height=Math.floor(r.height*DPR);ctx.setTransform(DPR,0,0,DPR,0,0);draw()}
  window.addEventListener('resize',resize);

  const azimuth=document.getElementById('azimuth');
  const elevation=document.getElementById('elevation');
  const camDist=document.getElementById('camDist');
  const fov=document.getElementById('fov');
  const gridN=document.getElementById('gridN');
  const spacing=document.getElementById('spacing');
  const maxH=document.getElementById('maxH');
  const heightStep = document.getElementById('heightStep');
  const strokeW=document.getElementById('strokeW');
  const seedEl=document.getElementById('seed');
  const btnApplySeed=document.getElementById('btn-apply-seed');
  const btnRandomSeed=document.getElementById('btn-random-seed');
  const btnResetView=document.getElementById('btn-reset-view');
  const btnSaveSvg=document.getElementById('btn-save-svg');

  [azimuth,elevation,camDist,fov,gridN,spacing,maxH,strokeW].forEach(el=>el.addEventListener('input',draw));
  btnResetView.addEventListener('click',()=>{azimuth.value=45;elevation.value=35;camDist.value=90;fov.value=55;draw()});
  btnSaveSvg.addEventListener('click', exportSVG);
  function randomizeSeed(){seedEl.value='city-'+Math.random().toString(16).slice(2,8);rebuildScene()}
  btnRandomSeed.addEventListener('click',randomizeSeed);
  btnApplySeed.addEventListener('click',rebuildScene);
  gridN.addEventListener('change',rebuildScene);
  spacing.addEventListener('change',rebuildScene);
  maxH.addEventListener('change',rebuildScene);
  heightStep.addEventListener('input', rebuildScene);

  // Orbit (invert Y)
  let dragging=false,lastX=0,lastY=0;
  canvas.addEventListener('mousedown',e=>{dragging=true;lastX=e.clientX;lastY=e.clientY});
  window.addEventListener('mouseup',()=>dragging=false);
  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
    azimuth.value=((parseFloat(azimuth.value)+dx*0.5)%360+360)%360;
    // inverted Y: dragging up lowers elevation
    elevation.value=Math.min(85,Math.max(5,parseFloat(elevation.value)+dy*0.3));
    draw();
  });

  // Trackpad scroll to zoom
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const min = parseFloat(camDist.min), max = parseFloat(camDist.max);
    const cur = parseFloat(camDist.value);
    const k = e.ctrlKey ? 0.02 : 0.1;
    const next = Math.min(max, Math.max(min, cur + e.deltaY * k));
    camDist.value = String(next);
    draw();
  }, { passive:false });

  // --- City data + Scene BSP (world space) ---
  let city={normHeights:[],n:parseInt(gridN.value)};
  let sceneBSP=null;
  let drawableEdgeKeys=null; // Set of world-edge keys to stroke (no internal seams)
  const EDGE_Q=1e-4; // edge quantization in world units

  function buildFaces(n, spacingPx, H, stepQ){
    const cell=12, step=cell+spacingPx, half=(n-1)*step*0.5;
    const faces=[];
    for(let j=0;j<n;j++)for(let i=0;i<n;i++){
      const hRaw = city.normHeights[j*n+i]*H;
      const h = stepQ > 0 ? Math.round(hRaw / stepQ) * stepQ : hRaw;  // ← quantized height

      const cx=i*step-half, cy=j*step-half, s=cell;
      const x1=cx-s*0.5,x2=cx+s*0.5,y1=cy-s*0.5,y2=cy+s*0.5,z0=0,z1=h;

      const p000=[x1,y1,z0], p100=[x2,y1,z0], p110=[x2,y2,z0], p010=[x1,y2,z0];
      const p001=[x1,y1,z1], p101=[x2,y1,z1], p111=[x2,y2,z1], p011=[x1,y2,z1];

      const quads=[
        [p001,p101,p111,p011], // top
        [p000,p100,p101,p001], // side 1
        [p100,p110,p111,p101], // side 2
        [p110,p010,p011,p111], // side 3
        [p010,p000,p001,p011], // side 4
      ];

      for(const q of quads){
        const e1=[q[1][0]-q[0][0],q[1][1]-q[0][1],q[1][2]-q[0][2]];
        const e2=[q[2][0]-q[0][0],q[2][1]-q[0][1],q[2][2]-q[0][2]];
        const normal=V.norm([ e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0] ]);
        const center=[(q[0][0]+q[1][0]+q[2][0]+q[3][0])/4,(q[0][1]+q[1][1]+q[2][1]+q[3][1])/4,(q[0][2]+q[1][2]+q[2][2]+q[3][2])/4];
        faces.push({verts:q, faceId:faces.length, normal});
      }
    }
    return faces;
  }


  // -------- BSP over world-space polys --------
  const EPS = 1e-6;
  function sideOfPlane(plane, p, eps=EPS){
    const s = plane[0]*p[0] + plane[1]*p[1] + plane[2]*p[2] + plane[3];
    return s > eps ?  1 : (s < -eps ? -1 : 0);
  }
  function planeOf(poly){
    const v=poly.verts;
    for(let i=1;i<v.length-1;i++){
      const a=v[0], b=v[i], c=v[i+1];
      const ux=b[0]-a[0], uy=b[1]-a[1], uz=b[2]-a[2];
      const vx=c[0]-a[0], vy=c[1]-a[1], vz=c[2]-a[2];
      let nx=uy*vz-uz*vy, ny=uz*vx-ux*vz, nz=ux*vy-uy*vx;
      const len=Math.hypot(nx,ny,nz);
      if (len>EPS){
        nx/=len; ny/=len; nz/=len;
        const d = -(nx*a[0]+ny*a[1]+nz*a[2]);
        return [nx,ny,nz,d];
      }
    }
    return [0,0,1,0];
  }
  function triArea3(a,b,c){
    const ux=b[0]-a[0], uy=b[1]-a[1], uz=b[2]-a[2];
    const vx=c[0]-a[0], vy=c[1]-a[1], vz=c[2]-a[2];
    const cx=uy*vz-uz*vy, cy=uz*vx-ux*vz, cz=ux*vy-uy*vx;
    return Math.hypot(cx,cy,cz)*0.5;
  }
  function chooseSplitter(polys){
    let best=0, bestA=-1;
    for(let i=0;i<polys.length;i++){
      const v=polys[i].verts; let A=0;
      for(let k=1;k<v.length-1;k++) A += triArea3(v[0],v[k],v[k+1]);
      if(A>bestA){ bestA=A; best=i; }
    }
    return best;
  }
  function splitPolyByPlaneWorld(plane, poly){
    const v=poly.verts, outF=[], outB=[];
    let front=[], back=[];
    for(let i=0;i<v.length;i++){
      const a=v[i], b=v[(i+1)%v.length];
      const da = plane[0]*a[0]+plane[1]*a[1]+plane[2]*a[2]+plane[3];
      const db = plane[0]*b[0]+plane[1]*b[1]+plane[2]*b[2]+plane[3];
      const sa = da>EPS?1:da<-EPS?-1:0;
      const sb = db>EPS?1:db<-EPS?-1:0;

      if (sa >= 0) front.push(a); else if (sa < 0) back.push(a); else { front.push(a); back.push(a); }

      if (sa*sb < 0){
        const t = da / (da - db);
        const m = [ a[0] + t*(b[0]-a[0]), a[1] + t*(b[1]-a[1]), a[2] + t*(b[2]-a[2]) ];
        front.push(m); back.push(m);
      }
    }
    if (front.length>=3) outF.push({ verts:front, faceId:poly.faceId, normal:poly.normal });
    if (back.length>=3)  outB.push({ verts:back,  faceId:poly.faceId, normal:poly.normal });
    return {front:outF, back:outB};
  }
  function buildBSPWorld(polys){
    if (!polys.length) return null;
    const idx = chooseSplitter(polys);
    const splitter = polys[idx];
    const plane = planeOf(splitter);
    const cop=[], front=[], back=[];
    for(let k=0;k<polys.length;k++){
      const p=polys[k];
      if (k===idx){ cop.push(p); continue; }
      let pos=0, neg=0;
      for (const v of p.verts){ const s=sideOfPlane(plane, v); if(s>0) pos=1; else if(s<0) neg=1; }
      if (pos && neg){
        const sp=splitPolyByPlaneWorld(plane,p);
        front.push(...sp.front); back.push(...sp.back);
      } else if (pos){ front.push(p); }
      else if (neg){ back.push(p); }
      else { cop.push(p); }
    }
    return { plane, cop, front:buildBSPWorld(front), back:buildBSPWorld(back) };
  }
  function traverseBSPWorld(node, eye, out){
    if(!node) return;
    const side = sideOfPlane(node.plane, eye);
    if (side > 0){
      traverseBSPWorld(node.back, eye, out);
      out.push(...node.cop);
      traverseBSPWorld(node.front, eye, out);
    } else {
      traverseBSPWorld(node.front, eye, out);
      out.push(...node.cop);
      traverseBSPWorld(node.back, eye, out);
    }
  }
  function collectAllPolys(node, arr){
    if(!node) return;
    arr.push(...node.cop);
    collectAllPolys(node.front, arr);
    collectAllPolys(node.back, arr);
  }

  // --- Edge map (world) to skip seam edges from BSP splits ---
  function q(v,k=EDGE_Q){ return [Math.round(v[0]/k)*k, Math.round(v[1]/k)*k, Math.round(v[2]/k)*k]; }
  function pkey(v){ const p=q(v); return `${p[0]},${p[1]},${p[2]}`; }
  function ekey(a,b){ const A=pkey(a), B=pkey(b); return A<B ? A+'|'+B : B+'|'+A; }

  function buildDrawableEdges(bsp){
    const map=new Map(); // key -> {count, faceIds:Set}
    const polys=[]; collectAllPolys(bsp, polys);
    for(const poly of polys){
      const v=poly.verts;
      for(let i=0;i<v.length;i++){
        const a=v[i], b=v[(i+1)%v.length];
        const k=ekey(a,b);
        let rec=map.get(k);
        if(!rec){ rec={count:0, faceIds:new Set()}; map.set(k,rec); }
        rec.count++; rec.faceIds.add(poly.faceId);
      }
    }
    const drawable=new Set();
    for(const [k,rec] of map){
      // draw if it's a silhouette (count==1) or a crease (shared by different faces)
      if (rec.count===1 || rec.faceIds.size>1) drawable.add(k);
      // else: count>=2 and only one faceId -> internal seam from BSP split -> skip
    }
    return drawable;
  }

  // Build / rebuild whole scene (only when scene changes)
  function rebuildScene(){
    const n=parseInt(gridN.value);
    city.n=n;
    // heights
    const seedHash=xfnv1a(seedEl.value)();
    const rng=mulberry32(seedHash);
    const norm=new Array(n*n);
    for(let j=0;j<n;j++)for(let i=0;i<n;i++){
      const idx=j*n+i; const base=rng(); norm[idx]=Math.pow(base,2.2);
    }
    city.normHeights=norm;

    // world-space faces -> BSP -> drawable edges
    const faces = buildFaces(
      n,
      parseFloat(spacing.value),
      parseFloat(maxH.value),
      parseFloat(heightStep.value),
    );

    sceneBSP = buildBSPWorld(faces);
    drawableEdgeKeys = buildDrawableEdges(sceneBSP);

    draw();
  }

  // --- Rendering using scene BSP ---
  function draw(){
    const w=canvas.clientWidth,h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.lineWidth=parseFloat(strokeW.value);
    ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.strokeStyle='#000';

    const r=parseFloat(camDist.value), az=parseFloat(azimuth.value)*Math.PI/180, el=parseFloat(elevation.value)*Math.PI/180;
    const eye=[r*Math.cos(el)*Math.cos(az), r*Math.cos(el)*Math.sin(az), r*Math.sin(el)];
    const Vw=lookAt(eye,[0,0,0],[0,0,1]);
    const near=0.1, P=perspective(parseFloat(fov.value), w/h, near, 2000);

    // Back-to-front order from the *scene* BSP
    const ordered=[]; traverseBSPWorld(sceneBSP, eye, ordered);

    // Draw each polygon: fill *then* stroke, before moving on to the next
    for (const poly of ordered){
      const vv = poly.verts.map(p=>transformToView(Vw,p));
      const vvc = clipPolyAgainstNear(vv, near);
      if (vvc.length < 3) continue;

      const clip = vvc.map(p=>transformPt4(P,p));
      const s = clip.map(pt=>toScreen(pt,w,h));

      ctx.beginPath();
      ctx.moveTo(s[0][0], s[0][1]);
      for (let i=1;i<s.length;i++) ctx.lineTo(s[i][0], s[i][1]);
      ctx.closePath();

      ctx.fillStyle = '#fff';
      ctx.fill();          // covers any earlier background strokes
      ctx.stroke();        // outline for this face only
    }

    ctx.restore();
    const n=parseInt(gridN.value);
    hud.textContent = `az ${parseInt(azimuth.value)}°  el ${parseInt(elevation.value)}°  dist ${parseInt(camDist.value)}  fov ${parseInt(fov.value)}°  grid ${n}×${n}  order Scene BSP  maxH ${parseInt(maxH.value)}  qStep ${parseInt(heightStep.value)}`;
  }

  // --- SVG export ---
  function exportSVG(){
    const w=canvas.clientWidth,h=canvas.clientHeight, sw=parseFloat(strokeW.value);
    const r=parseFloat(camDist.value), az=parseFloat(azimuth.value)*Math.PI/180, el=parseFloat(elevation.value)*Math.PI/180;
    const eye=[r*Math.cos(el)*Math.cos(az), r*Math.cos(el)*Math.sin(az), r*Math.sin(el)];
    const Vw=lookAt(eye,[0,0,0],[0,0,1]);
    const near=0.1, P=perspective(parseFloat(fov.value), w/h, near, 2000);

    const ordered=[]; traverseBSPWorld(sceneBSP, eye, ordered);

    const xmlns='http://www.w3.org/2000/svg';
    const svg=document.createElementNS(xmlns,'svg');
    svg.setAttribute('xmlns',xmlns);
    svg.setAttribute('width',String(w));
    svg.setAttribute('height',String(h));
    svg.setAttribute('viewBox',`0 0 ${w} ${h}`);

    // White background to mimic canvas occlusion
    const bg=document.createElementNS(xmlns,'rect');
    bg.setAttribute('x','0'); bg.setAttribute('y','0'); bg.setAttribute('width',String(w)); bg.setAttribute('height',String(h));
    bg.setAttribute('fill','#ffffff');
    svg.appendChild(bg);

    const toPathD=(poly)=>{
      let d=`M ${poly[0][0]} ${poly[0][1]}`;
      for(let i=1;i<poly.length;i++) d += ` L ${poly[i][0]} ${poly[i][1]}`;
      return d+' Z';
    };

    // Per-polygon: fill+stroke in BSP order
    for (const poly of ordered){
      const vv = poly.verts.map(p=>transformToView(Vw,p));
      const vvc = clipPolyAgainstNear(vv, near);
      if (vvc.length < 3) continue;

      const clip = vvc.map(p=>transformPt4(P,p));
      const s = clip.map(pt=>toScreen(pt,w,h));

      const path=document.createElementNS(xmlns,'path');
      path.setAttribute('d',toPathD(s));
      path.setAttribute('fill','#ffffff');
      path.setAttribute('stroke','#000000');
      path.setAttribute('stroke-width',String(sw));
      path.setAttribute('stroke-linejoin','round');
      path.setAttribute('stroke-linecap','round');
      svg.appendChild(path);
    }

    const blob=new Blob([new XMLSerializer().serializeToString(svg)],{type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='city.svg'; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),0);
  }

  // Init
  function init(){rebuildScene(); resize();}
  window.addEventListener('load',init);
</script>
</body>
</html>
