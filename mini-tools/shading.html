<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Icosahedron – Per‑Face U‑Hatching with Shaded Spacing</title>
  <style>
    :root { --bg:#fff; --fg:#111; --ui:#f4f4f4; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #controls { position: absolute; top:0; left:0; bottom:0; width:260px; background: var(--ui); border-right:1px solid #ccc; padding:12px; overflow:auto; }
    #controls h2 { margin:8px 0 6px; font-size:14px; }
    #controls label { display:block; margin-top:10px; font-size:12px; }
    #controls .row { display:flex; align-items:center; gap:8px; margin-top:10px; }
    #wrap { position: absolute; left:260px; top:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; }
    canvas { display:block; }
    button { cursor:pointer; padding:6px 10px; border:1px solid #bbb; border-radius:6px; background:#fff; }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Camera</h2>
    <label for="az">Azimuth <span id="azVal">30°</span></label>
    <input id="az" type="range" min="0" max="360" value="30" step="1" />
    <label for="el">Elevation <span id="elVal">15°</span></label>
    <input id="el" type="range" min="-89" max="89" value="15" step="1" />

    <h2>Hatching (spacing by shade)</h2>
    <label for="hBlack">Black spacing <span id="hBlackVal">2 px</span></label>
    <input id="hBlack" type="range" min="1" max="12" value="2" step="1" />
    <label for="hWhite">White spacing <span id="hWhiteVal">14 px</span></label>
    <input id="hWhite" type="range" min="6" max="30" value="14" step="1" />

    <div class="row">
      <input id="strokeOutlines" type="checkbox" checked />
      <label for="strokeOutlines" style="margin:0">Stroke outlines</label>
    </div>
    <div class="row">
      <button id="saveSvg">Save SVG</button>
      <span style="font-size:12px; opacity:.7">exports current view</span>
    </div>
  </div>
  <div id="wrap"><canvas id="c"></canvas></div>

  <script>
  (function(){
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const wrap = document.getElementById('wrap');

    // Controls
    const az = document.getElementById('az');
    const el = document.getElementById('el');
    const azVal = document.getElementById('azVal');
    const elVal = document.getElementById('elVal');
    const hBlack = document.getElementById('hBlack');
    const hBlackVal = document.getElementById('hBlackVal');
    const hWhite = document.getElementById('hWhite');
    const hWhiteVal = document.getElementById('hWhiteVal');
    const strokeOutlines = document.getElementById('strokeOutlines');
    const saveSvgBtn = document.getElementById('saveSvg');

    // Fit canvas to available space using A4 landscape aspect ratio (W/H = 297/210 ≈ 1.414)
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const rect = wrap.getBoundingClientRect();
      const aspect = 297/210; // width / height
      let targetW = rect.width;
      let targetH = targetW / aspect;
      if (targetH > rect.height) { // too tall, clamp by height instead
        targetH = rect.height;
        targetW = targetH * aspect;
      }
      // Apply CSS size and backing store with DPR
      canvas.style.width = Math.floor(targetW) + 'px';
      canvas.style.height = Math.floor(targetH) + 'px';
      canvas.width = Math.max(1, Math.floor(targetW * dpr));
      canvas.height = Math.max(1, Math.floor(targetH * dpr));

      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
      render();
    }
    window.addEventListener('resize', resizeCanvas);

    // ===== Icosahedron geometry =====
    const PHI = (1 + Math.sqrt(5)) / 2; // golden ratio
    const rawVerts = [
      [-1,  PHI,  0], [ 1,  PHI,  0], [-1, -PHI,  0], [ 1, -PHI,  0],
      [ 0, -1,  PHI], [ 0,  1,  PHI], [ 0, -1, -PHI], [ 0,  1, -PHI],
      [  PHI,  0, -1], [  PHI,  0,  1], [ -PHI,  0, -1], [ -PHI,  0,  1]
    ];

    const len3 = ([x,y,z]) => Math.hypot(x,y,z);

    // Normalize to unit radius
    const k = 1 / len3(rawVerts[0]);
    const V = rawVerts.map(([x,y,z]) => [x*k, y*k, z*k]);

    // Faces (20 triangles)
    const F = [
      [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
      [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
      [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
      [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]
    ];

    // Rotations
    const rotY = ([x,y,z],a)=>{ const c=Math.cos(a), s=Math.sin(a); return [ c*x + s*z, y, -s*x + c*z ]; };
    const rotX = ([x,y,z],a)=>{ const c=Math.cos(a), s=Math.sin(a); return [ x, c*y - s*z, s*y + c*z ]; };

    // Camera / projection
    let fov = 60 * Math.PI/180;
    let zOffset = 3.0; // push model in front of camera
    let near = 0.1;

    function project([x,y,z], cw, ch){
      const scale = ch / (2 * Math.tan(fov/2));
      return [ cw*0.5 + (x/z)*scale, ch*0.5 - (y/z)*scale ];
    }

    // Lighting (your darker rig, no ambient)
    const norm3 = (v)=>{ const L = Math.hypot(v[0],v[1],v[2])||1; return [v[0]/L, v[1]/L, v[2]/L]; };
    const lights = [
      { dir: norm3([-0.5,  1.7,  0.4]), intensity: 1.1 }, // key (up-left-front, higher)
      { dir: norm3([ 1.0,  0.05, 0.2]), intensity: 0.1 }, // fill (barely there)
    ];

    // --- Hatch drawing on canvas (rotate context, long lines, clipped to triangle) ---
    function hatchTriangleCanvas(ax,ay,bx,by,cx,cy, angleDeg, spacing){
      ctx.save();
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.lineTo(cx,cy); ctx.closePath();
      ctx.clip();
      const theta = angleDeg * Math.PI / 180;
      ctx.rotate(theta);
      const big = Math.hypot(canvas.clientWidth, canvas.clientHeight) + 4;
      ctx.beginPath();
      for (let y = -big; y <= big; y += spacing){ ctx.moveTo(-big, y); ctx.lineTo(big, y); }
      ctx.stroke();
      ctx.restore();
    }

    // Compute visible faces with screen coords, per-face angle, spacing, and depth
    function computeFaces(){
      const cw = canvas.clientWidth|0, ch = canvas.clientHeight|0;
      const ay = (parseFloat(az.value)||0) * Math.PI/180;
      const ax = (parseFloat(el.value)||0) * Math.PI/180;
      let blackSpacing = (parseFloat(hBlack.value)||2);
      let whiteSpacing = (parseFloat(hWhite.value)||14);
      if (whiteSpacing < blackSpacing) { const t = whiteSpacing; whiteSpacing = blackSpacing; blackSpacing = t; }

      // Transform vertices to camera space
      const TV = V.map(v => { let r = rotY(v, ay); r = rotX(r, ax); return [r[0], r[1], r[2] + zOffset]; });

      const faces = [];
      for (const [i,j,k] of F){
        const a = TV[i], b = TV[j], c = TV[k];
        if (a[2]<=near||b[2]<=near||c[2]<=near) continue;
        const ux=b[0]-a[0], uy=b[1]-a[1], uz=b[2]-a[2];
        const vx=c[0]-a[0], vy=c[1]-a[1], vz=c[2]-a[2];
        const nx = uy*vz - uz*vy;
        const ny = uz*vx - ux*vz;
        const nz = ux*vy - uy*vx;
        const mx = (a[0]+b[0]+c[0])/3, my = (a[1]+b[1]+c[1])/3, mz = (a[2]+b[2]+c[2])/3;
        const facing = nx*mx + ny*my + nz*mz;
        if (facing >= 0) continue; // backface culling

        // Shade (0..1)
        const NL = Math.hypot(nx,ny,nz) || 1;
        const nxf = nx/NL, nyf = ny/NL, nzf = nz/NL;
        let shade = 0.0;
        for (const L of lights){
          const ndotl = nxf*L.dir[0] + nyf*L.dir[1] + nzf*L.dir[2];
          if (ndotl > 0) shade += L.intensity * ndotl;
        }
        shade = Math.max(0, Math.min(1, shade));
        const spacing = blackSpacing + (whiteSpacing - blackSpacing) * shade;

        // Screen projection
        const [axp, ayp] = project(a, cw, ch);
        const [bxp, byp] = project(b, cw, ch);
        const [cxp, cyp] = project(c, cw, ch);

        // Per-face u-direction from edge AB in screen space
        const ux2 = bxp - axp;
        const uy2 = byp - ayp;
        const angleDeg = Math.atan2(uy2, ux2) * 180 / Math.PI;

        const zAvg = (a[2]+b[2]+c[2])/3;
        faces.push({ axp,ayp,bxp,byp,cxp,cyp, angleDeg, spacing, z:zAvg });
      }
      faces.sort((A,B)=> B.z - A.z);
      return { faces, cw, ch };
    }

    function render(){
      const { faces, cw, ch } = computeFaces();
      ctx.clearRect(0,0,cw,ch);
      ctx.lineWidth = 1; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#111';
      // UI text
      azVal.textContent = `${Math.round(parseFloat(az.value)||0)}°`;
      elVal.textContent = `${Math.round(parseFloat(el.value)||0)}°`;
      hBlackVal.textContent = `${Math.round(parseFloat(hBlack.value)||2)} px`;
      hWhiteVal.textContent = `${Math.round(parseFloat(hWhite.value)||14)} px`;

      for (const f of faces){
        hatchTriangleCanvas(f.axp,f.ayp,f.bxp,f.byp,f.cxp,f.cyp, f.angleDeg, f.spacing);
        if (strokeOutlines.checked){
          ctx.beginPath();
          ctx.moveTo(f.axp, f.ayp); ctx.lineTo(f.bxp, f.byp); ctx.lineTo(f.cxp, f.cyp); ctx.closePath();
          ctx.stroke();
        }
      }
    }

    // --- SVG Export (pre-clipped segments; no clipPaths) ---
    function exportSVG(){
      const { faces, cw, ch } = computeFaces();
      const big = Math.hypot(cw, ch) + 4; // untrimmed segment extent along u

      // Helper: build inward half-planes for triangle and clip a segment
      function makePlanes(tri){
        const [A,B,C] = tri;
        const planes = [];
        const edges = [[A,B,C],[B,C,A],[C,A,B]];
        for (const [P,Q,R] of edges){
          const ex = Q.x - P.x, ey = Q.y - P.y;
          let nx = ey, ny = -ex; // one perpendicular
          // Flip so that R is INSIDE: n·(R-P) <= 0
          if (nx*(R.x-P.x) + ny*(R.y-P.y) > 0){ nx = -nx; ny = -ny; }
          planes.push({nx, ny, ax:P.x, ay:P.y});
        }
        return planes;
      }
      function clipSegment(p0, p1, planes){
        let t0 = 0, t1 = 1;
        const dx = p1.x - p0.x, dy = p1.y - p0.y;
        for (const pl of planes){
          const f0 = pl.nx*(p0.x - pl.ax) + pl.ny*(p0.y - pl.ay); // n·(p0 - A)
          const f1 = pl.nx*(p1.x - pl.ax) + pl.ny*(p1.y - pl.ay);
          const r = pl.nx*dx + pl.ny*dy; // n·d
          if (Math.abs(r) < 1e-9){ // parallel
            if (f0 > 0) return null; // entirely outside
            else continue; // inside wrt this plane
          }
          const t = -f0 / r; // intersection
          if (r > 0){ // entering
            t1 = Math.min(t1, t);
          } else {    // leaving
            t0 = Math.max(t0, t);
          }
          if (t0 > t1) return null;
        }
        return { x0: p0.x + dx*t0, y0: p0.y + dy*t0, x1: p0.x + dx*t1, y1: p0.y + dy*t1 };
      }

      const segs = [];
      for (const f of faces){
        // Axes from angle
        const theta = f.angleDeg * Math.PI/180;
        const ux = Math.cos(theta),  uy = Math.sin(theta);   // along hatch line
        const vx = -Math.sin(theta), vy = Math.cos(theta);   // normal to hatch lines
        const tri = [
          {x:f.axp, y:f.ayp},
          {x:f.bxp, y:f.byp},
          {x:f.cxp, y:f.cyp},
        ];
        const planes = makePlanes(tri);
        // Range along v that overlaps the triangle
        const p1 = f.axp*vx + f.ayp*vy;
        const p2 = f.bxp*vx + f.byp*vy;
        const p3 = f.cxp*vx + f.cyp*vy;
        let minP = Math.min(p1,p2,p3), maxP = Math.max(p1,p2,p3);
        const start = Math.floor((minP - big) / f.spacing) * f.spacing;
        const end   = Math.ceil ((maxP + big) / f.spacing) * f.spacing;
        for (let t = start; t <= end; t += f.spacing){
          const pA = { x: ux*(-big) + vx*t, y: uy*(-big) + vy*t };
          const pB = { x: ux*( big) + vx*t, y: uy*( big) + vy*t };
          const clipped = clipSegment(pA, pB, planes);
          if (clipped){
            segs.push(`<line x1="${clipped.x0.toFixed(3)}" y1="${clipped.y0.toFixed(3)}" x2="${clipped.x1.toFixed(3)}" y2="${clipped.y1.toFixed(3)}"/>`);
          }
        }
        if (strokeOutlines.checked){
          segs.push(`<path d="M ${f.axp.toFixed(3)} ${f.ayp.toFixed(3)} L ${f.bxp.toFixed(3)} ${f.byp.toFixed(3)} L ${f.cxp.toFixed(3)} ${f.cyp.toFixed(3)} Z"/>`);
        }
      }

      const svg = `<?xml version="1.0" encoding="UTF-8"?>
`+
`<svg xmlns="http://www.w3.org/2000/svg" width="${cw}" height="${ch}" viewBox="0 0 ${cw} ${ch}" fill="none" stroke="#111" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" vector-effect="non-scaling-stroke">`+
segs.join('')+
`</svg>`;

      const blob = new Blob([svg], {type:'image/svg+xml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'icosahedron_hatched.svg';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    // Initialize and hook events
    function hook(){
      [az, el, hBlack, hWhite, strokeOutlines].forEach(elm => elm.addEventListener('input', render));
      saveSvgBtn.addEventListener('click', exportSVG);
    }

    resizeCanvas();
    hook();
  })();
  </script>
</body>
</html>
